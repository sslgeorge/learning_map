# Outcome 8- Using a Library (Gems) 

Skill Description
----------
A person with this skill knows when their code would benefit from adding a Ruby Gem, how to choose an appropriate Gem, how to install it into his/her code, and how to apply it for his/her own needs. 

Outputs
----------
- **Task:** Create a Ruby application that connects to a database and allows the user to interact with data. 
- **Resources:** Use appropriate Gems to support your development 
- **Include:** Share this with your team. 

----------
## **Knowledge**


| Knowledge Unit   |      Studied      | Applied |
|:-------------|:------------------:|:--------:|
| Definition of a Gem and how it is used in Ruby programming | [ ] | [ ]  |
| How Gemfiles interact with Ruby code | [ ] | [ ]  |
| Definition of bundled Console and what it does | [ ] | [ ]  |
| How to add a database to my Ruby projects (eg. SQLite) | [ ] | [ ]  |
| How to use an ORM | [ ] | [ ]  |
| When to use a Library in Ruby | [ ] | [ ]  |
| The abstraction cost of using a library | [ ] | [ ]  |
| How to verify Gem security and why it matters | [ ] | [ ]  |
| How to verify that a Gem is licensed and why it matters | [ ] | [ ]  |
| How to extend a Gem | [ ] | [ ]  |
| How to read the documentation of a Gem | [ ] | [ ]  |
| How to “Play” to explore a Library/Gem | [ ] | [ ]  |
| The difference between the Public API and Private API of a Gem | [ ] | [ ]  |


----------


## **Behaviors**

| Observable Behavior   |      Practiced      | Observed |
|:-------------|:------------------:|:--------:|
| **Context:** When I realize I’m repeating boilerplate code over and over, **Action:** I detail out what I would need as an abstraction for that code. | [ ] | [ ]  |
| **Context:** When I have a clear idea of how to abstract my code repetition, **Action:** I consider whether I could write a method to solve that problem. | [ ] | [ ]  |
| **Context:**  When I realize it would take me more than a day to create a tool that would handle a problem in my code, **Action:** I start looking for a Gem to solve it instead. | [ ] | [ ]  |
| **Context:** When Ruby is no longer enjoyable, **Action:** I look for a Gem to handle the problem I’m fighting. 
| **Context:** When I am beginning to use a new Gem, **Action:** I read the documentation on how to use it and how to go deeper into the library. | [ ] | [ ]  |
| **Context:** When I have multiple gems, **Action:** I use bundled Console to load all my gems and code in the directory. | [ ] | [ ]  |
| **Context:** When I have a bug, **Action:** I break it down into small pieces and use a debugger to determine whether the error is in my code or the Gem code. | [ ] | [ ]  |
| **Context:** When the bug is in the Gem code, **Action:** I open the source code of the Gem and debug it from there (http://bundler.io/v1.10/bundle_open.html) | [ ] | [ ]  |
| **Context:** When a Gem is not working with my code the way I expect, **Action:** I test to determine if it is a bug I can fix or whether it is simply the wrong library for my task. | [ ] | [ ]  |
| **Context:** When I download a Gem, **Action:** I leverage the documentation to figure out how to use it. | [ ] | [ ]  |
| **Context:** When I install a new Library, **Action:** I read documentation and “play” to learn how the Gem interacts with my code. | [ ] | [ ]  |
| **Context:** When a library/Gem is small, **Action:** I read all the Documentation up front. | [ ] | [ ]  |
| **Context:** When I am considering using a complex library, **Action:** I first learn everything I can about it from its Readme description, GitHub Stars, issues closed, last updated date, and RubyGems Download numbers. | [ ] | [ ]  |
| **Context:** When I have Gems installed in my code, **Action:** I update at least quarterly to make sure I am still getting the most up-to-date version of the library. | [ ] | [ ]  |

----------


## **Beliefs**


| Embodied Belief   |      Felt      | Demonstrated |
|:-------------|:------------------:|:--------:|
| Gems take away the need for onerous tasks in Ruby-- Ruby should be enjoyable! | [ ] | [ ]  |
| When using a Gem, I am always making a tradeoff between ease of use and losing access to some of my program’s core logic. | [ ] | [ ]  |
| Powerful libraries do one thing and do it well. | [ ] | [ ]  |
| A good library is easy to extend-- I can make it do what I want. | [ ] | [ ]  |
| Using Gems can be addicting-- but I don’t let them become a quick-fix. | [ ] | [ ]  |
| Using Gems and reading their documentation is helpful in learning to write my own code better. | [ ] | [ ]  |
